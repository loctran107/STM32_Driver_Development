/*
 * STM32F407xx_USART_UART_Driver.c
 *
 *  Created on: Sep 16, 2020
 *      Author: Donavan Tran
 */

#include "../drivers/Inc/stm32f407xx.h"

/*
 * Helper functions that are private to user applications
 */
static uint32_t getAPBxClkFreq(USART_Reg_t* pUSARTx);
static uint32_t getPLLClkFreq();
static double getUSARTDiv(USART_Handle_t* pUARTHandler);

/*****************************************************
 * @fn					- USART_PeriClkCtrl
 *
 * @brief				- Enable or disable the USARTx clock peripherals
 *
 * @param[in]			- Base address of the specific USART
 * @param[in]			- ENABLE or DISABLE macro
 *
 * @return				- none
 * @note				- none
 */
void USART_PeriClkCtrl(USART_Reg_t* pUSARTx, uint8_t EnOrDi) {
	if (EnOrDi) {
		USARTx_PCLK_EN(pUSARTx); //Go to I2Cx_PCLK_EN macro for more details
	} else {
		USARTx_PCLK_DI(pUSARTx); //Go to I2Cx_PCLK_DI macro for more details
	}
}

/*****************************************************
 * @fn					- USART_Init
 *
 * @brief				- Initialize the USART port given the handle structure
 *
 * @param[in]			- Handle Structure of USART that contains all USART configuration
 * 						  and port
 *
 * @return				- none
 * @note				- none
 */
void USART_Init(USART_Handle_t* pUSARTHandler) {

	double USARTDiv;
	uint16_t mantissa;
	uint8_t fraction;
	//Enable the peripheral clock
	USART_PeriClkCtrl(pUSARTHandler->pUSARTx, ENABLE);


	//Configure USART mode
	switch (pUSARTHandler->USART_Config.Mode) {
	case USART_MODE_ONLY_TX:	//Set the TE bit in USART_CR to send an idle frame as the first transmission
								pUSARTHandler->pUSARTx->CR1 |= 1 << USART_CR1_TE;
								break;

	case USART_MODE_ONLY_RX:	//Set the TE bit in USART_CR to send an idle frame as the first transmission
								pUSARTHandler->pUSARTx->CR1 |= 1 << USART_CR1_RE;
								break;

	case USART_MODE_TX_RX:		pUSARTHandler->pUSARTx->CR1 |= 1 << USART_CR1_TE;
								pUSARTHandler->pUSARTx->CR1 |= 1 << USART_CR1_RE;
								break;

	}
	//Configure the parity control
	if (pUSARTHandler->USART_Config.ParityControl != USART_PARITY_DI) {

		//Enable the Parity control
		pUSARTHandler->pUSARTx->CR1 |= 1 << USART_CR1_PCE;

		//Set the parity bit control
		pUSARTHandler->pUSARTx->CR1 |= pUSARTHandler->USART_Config.ParityControl << USART_CR1_PS;

	}

	//Configure the over-sampling
	pUSARTHandler->pUSARTx->CR1 |= pUSARTHandler->USART_Config.Oversampling << USART_CR1_OVER8;

	//Configure the word length
	pUSARTHandler->pUSARTx->CR1 |= pUSARTHandler->USART_Config.WordLength << USART_CR1_M;

	//Configure the number of stop bits
	pUSARTHandler->pUSARTx->CR2 |= pUSARTHandler->USART_Config.NoOfStopBits << USART_CR2_STOP;

	//Configure the HW flow control
	if (pUSARTHandler->USART_Config.HWFlowControl != USART_HW_FLOW_CTRL_NONE) {

		//Enable CTS bit
		if (pUSARTHandler->USART_Config.HWFlowControl == USART_HW_FLOW_CTRL_CTS) {
			pUSARTHandler->pUSARTx->CR3 |= pUSARTHandler->USART_Config.HWFlowControl << USART_CR3_CTSE;
		}
		//Enable RTS bit
		else if (pUSARTHandler->USART_Config.HWFlowControl == USART_HW_FLOW_CTRL_RTS) {
			pUSARTHandler->pUSARTx->CR3 |= pUSARTHandler->USART_Config.HWFlowControl << USART_CR3_RTSE;
		}
		//Enable both RTS and CTS
		else {
			pUSARTHandler->pUSARTx->CR3 |= pUSARTHandler->USART_Config.HWFlowControl << USART_CR3_CTSE;
			pUSARTHandler->pUSARTx->CR3 |= pUSARTHandler->USART_Config.HWFlowControl << USART_CR3_RTSE;
		}
	}

}

/*****************************************************
 * @fn					- USART_DeInit
 *
 * @brief				- Reset the entire register configuration of the specific USART port
 *
 * @param[in]			- Base address of the specific SPI peripherals (USART_Reg_t* pUSARTx)
 *
 * @return				- none
 * @note				- The implementation so far only covers only 6 USART/USART ports
 */
void USART_DeInit(USART_Reg_t* pUSARTx) {
	if (pUSARTx == USART1) {
		USART1_PCLK_RST();
	} else if (pUSARTx == USART2) {
		USART2_PCLK_RST();
	} else if (pUSARTx == USART3) {
		USART3_PCLK_RST();
	} else if (pUSARTx == UART4) {
		UART4_PCLK_RST();
	} else if (pUSARTx == UART5) {
		UART5_PCLK_RST();
	} else {
		USART6_PCLK_RST();
	}
}

/*****************************************************
 * @fn					- USART_PeripheralEnable
 *
 * @brief				- Enable that specific USART peripheral
 *
 * @param[in]			- Base address of the specific USART peripherals (USART_Reg_t* pUSARTx)
 * @param[in]			= ENABLE or DISABLE macro
 *
 * @return				- none
 * @note				- none
 */
void USART_PeripheralEnable(USART_Reg_t* pUSARTx, uint8_t EnOrDi) {
	if (EnOrDi) {
		pUSARTx->CR1 |= 1 << USART_CR1_UE;
	} else {
		pUSARTx->CR1 &= ~(1 << USART_CR1_UE);
	}
}

/*****************************************************
 * @fn					- USART_SendData
 *
 * @brief				- Send data to other connected USART/UART device
 *
 * @param[in]			- Base address of the specific USART peripherals (USART_Reg_t* pUSARTx)
 * @param[in]			- buffer for transmission (TxBuffer)
 * @param[in]			- length of the buffer (len)
 *
 * @return				- none
 * @note				- See the MCU Reference Manual for more details
 */
void USART_SendData(USART_Reg_t* pUSARTx, uint8_t* pTxBuffer, uint32_t len) {

	//Enable the USART by writing UE bit in USART_CR1 register
	USART_PeripheralEnable(pUSARTx, ENABLE);

	while (len) {
		//Poll until TXE is set
		while (!USART_CheckStatusFlag(&pUSARTx->SR, USART_FLAG_SR_TXE));

		//Write buffer into the data register
		pUSARTx->DR = *pTxBuffer;
		len--;
		pTxBuffer++;

		//Wait until the transmission is complete
		while (!USART_CheckStatusFlag(&pUSARTx->SR, USART_FLAG_SR_TC));
	}

	//Disable the USART by resetting UE bit in USART_CR1 register
	USART_PeripheralEnable(pUSARTx, DISABLE);
}

/*****************************************************
 * @fn					- USART_ReceiveData
 *
 * @brief				- Receive data from other connected USART/UART device
 *
 * @param[in]			- Base address of the specific USART peripherals (USART_Reg_t* pUSARTx)
 * @param[in]			- buffer for reception (RxBuffer)
 * @param[in]			- length of the buffer (len)
 *
 * @return				- none
 * @note				- See the MCU Reference Manual for more details
 */
void USART_ReceiveData(USART_Reg_t* pUSARTx, uint8_t* pRxBuffer, uint32_t len) {

	//Enable the USART by writing UE bit in USART_CR1 register
	USART_PeripheralEnable(pUSARTx, ENABLE);

	while (len) {
		//Poll until TXE is set
		while (!USART_CheckStatusFlag(&pUSARTx->SR, USART_FLAG_SR_TXE));

		//Write buffer into the data register
		*pRxBuffer = pUSARTx->DR;
		len--;
		pRxBuffer++;
	}

	//Disable the USART by resetting UE bit in USART_CR1 register
	USART_PeripheralEnable(pUSARTx, DISABLE);


}

/*****************************************************
 * @fn					- USART_IRQITConfig
 *
 * @brief				- USART Interrupt configuration
 *
 * @param[in]			- IRQ Number of the USART interrupt peripheral
 * @param[in]			= ENABLE or DISABLE macro
 *
 * @return				- none
 * @note				- Refer to the Cortex M4 Generic User Guide the NVIC register table
 */
void USART_IRQITConfig(uint8_t IRQNumber, uint8_t EnOrDi) {
	//In order to trigger the interrupt on the processor side,
	//configuration enable on the ISER of the NVIC is needed
	//Note: There are 7 different NVIC_ISER and NVIC_ICER register
	//at certain range
	uint32_t indx, remainder;
	indx = IRQNumber >> 5U; //Index to configure the correct NVIC_ISER
	if (indx >= 0U  && indx <= 7U) {
		remainder = IRQNumber & (~(~(int)0 << 5U)); //find the remainder
		if (EnOrDi) {
			NVIC_ISER(indx) |= 1 << remainder; //See NVIC_ISER(__INDEX__) declaration for more implementation details
		} else {
			NVIC_ICER(indx) |= 1 << remainder; //See NVIC_ICER(__INDEX__) declaration for more implementation details
		}
	}
}

/*****************************************************
 * @fn					- USART_IRQPriorityConfig
 *
 * @brief				- USART Interrupt Priority Configuration
 *
 * @param[in]			- IRQ number of the I2C interrupt peripheral
 * @param[in]			= The priority value of that USART interrupt peripheral
 *
 * @return				- none
 * @note				- Refer to the Cortex M4 Generic User Guide the NVIC register table
 */
void USART_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriorityValue) {
	uint32_t indx = IRQNumber >> 2U; //Note: There are IRQ Priority field in each IPR register
	uint32_t remainder = IRQNumber & (~(~(int)0 << 2U));
	uint32_t shift_amount = (remainder * 8U) + IMPLEMENTED_IRQ_PRIORITY_BIT;

	//Configure the IRQ_PR register
	NVIC_IPR(indx) |= IRQPriorityValue << shift_amount;
}

/*****************************************************
 * @fn					- USART_CheckStatusFlag
 *
 * @brief				- Check the status of the given flag in register
 *
 * @param[in]			- address of status register of specific USART peripherals
 * @param[in]			- the status flag
 *
 * @return				- none
 * @note				- none
 */
uint8_t USART_CheckStatusFlag(__vo uint32_t* statusReg, uint16_t flag) {
	if ((*statusReg) & flag) {
		return FLAG_SET;
	}
	return FLAG_RESET;
}

/*****************************************************
 * @fn					- getPLLClkFreq();
 *
 * @brief				- This helper function returns the current I2C clock frequency PLL
 * 						  bus is supplying to this peripheral
 *
 * @param[in]			-
 *
 * @return				- none
 * @note				- See the Clock Tree diagram in STM32F4xx Reference Manual for details
 */
static uint32_t getPLLClkFreq() {

	//Implemented later
	return 1;
}

/*****************************************************
 * @fn					- getAPBxClkFreq();
 *
 * @brief				- This helper function returns the current USART clock frequency APB1
 * 						  bus is supplying to this peripheral
 *
 * @param[in]			-
 *
 * @return				- none
 * @note				- See the Clock Tree diagram in STM32F4xx Reference Manual for details
 */
static uint32_t getAPBxClkFreq(USART_Reg_t* pUSARTx) {

	uint16_t temp, AHB1Prescalar,  APBxPrescalar;
	uint16_t AHB1PreSclr[9] = {1, 2, 4, 6, 16, 64, 128, 256, 512};
	uint16_t APBxPreSclr[5] = {1, 2, 4, 8, 16};
	uint32_t sysClk;

	//Determine what system clock the MCU is running
	switch ((RCC->CFGR >> 2U) & 0x3) {
	case RCC_HSE:	sysClk = HSE_CLK_FREQ; break; //8MHz
	case RCC_HSI:	sysClk = HSI_CLK_FREQ; break; //16MHz
	case RCC_PLL:	sysClk = getPLLClkFreq(); break; //See this function implementation for details
	}

	//Determine the prescalar factor AHB1 is using
	temp = (RCC->CFGR >> 4U) & 0xF;
	AHB1Prescalar = (temp < 8U) ? AHB1PreSclr[0] : AHB1PreSclr[temp % 8 + 1];

	//Determine the prescalar factor APB1 is using
	if (pUSARTx == USART2 || pUSARTx == USART3 || pUSARTx == UART4 || pUSARTx == UART5) {
		//USART2, USART3, UART4, UART5 hang on APB1
		temp = (RCC->CFGR >> 10U) & 0x7;
	} else {
		//USART1 and USART6 hang on APB2
		temp = (RCC->CFGR >> 13U) & 0x7;
	}
	APBxPrescalar = (temp < 4U) ? APBxPreSclr[0] : APBxPreSclr[temp % 8 + 1];

	//Return the APB1 clock freq
	return (sysClk / AHB1Prescalar) / APBxPrescalar;
}

static double getUSARTDiv(USART_Handle_t* pUARTHandler) {

	uint8_t factor = (pUARTHandler->USART_Config.Oversampling == USART_OVERSAMPLING_BY_8) ? 8 : 16;
	uint32_t APBxClkFreq = getAPBxClkFreq(pUARTHandler->pUSARTx);

	return APBxClkFreq / (factor * pUARTHandler->USART_Config.BaudRate);
}
